name: Production Rollback

on:
  workflow_dispatch:
    inputs:
      deployment_id:
        description: 'Deployment ID to rollback from (GitHub run ID)'
        required: true
        type: string
      reason:
        description: 'Reason for rollback'
        required: true
        type: string
      confirm:
        description: 'Type "ROLLBACK" to confirm'
        required: true
        type: string

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: django-microservices

jobs:
  # Job 1: Rollback validation
  validate-rollback:
    name: Validate Rollback Request
    runs-on: ubuntu-latest
    environment: production
    outputs:
      rollback_info: ${{ steps.info.outputs.rollback_info }}
      should_rollback: ${{ steps.validate.outputs.should_rollback }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "ROLLBACK" ]; then
            echo "âŒ Rollback not confirmed. Please type 'ROLLBACK' to confirm."
            exit 1
          fi
          echo "âœ… Rollback confirmed"
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Get rollback information
        id: info
        run: |
          # Download rollback info from S3
          if aws s3 cp s3://${{ secrets.BACKUP_S3_BUCKET }}/rollback-info/production-${{ github.event.inputs.deployment_id }}.json rollback-info.json; then
            echo "rollback_info=$(cat rollback-info.json | jq -c .)" >> $GITHUB_OUTPUT
            echo "âœ… Rollback information found"
            
            # Display rollback info
            echo "Rollback Information:"
            cat rollback-info.json | jq .
          else
            echo "âŒ Rollback information not found for deployment ID: ${{ github.event.inputs.deployment_id }}"
            exit 1
          fi
          
      - name: Validate rollback feasibility
        id: validate
        run: |
          # Get current production state
          services=("api-gateway" "user-service" "product-service" "order-service" "notification-service")
          
          echo "Checking current production state..."
          
          all_healthy=true
          for service in "${services[@]}"; do
            # Check if service exists and is running
            running_count=$(aws ecs describe-services \
              --cluster ${{ env.PROJECT_NAME }}-cluster \
              --services ${{ env.PROJECT_NAME }}-$service \
              --query 'services[0].runningCount' \
              --output text 2>/dev/null || echo "0")
            
            if [ "$running_count" -eq 0 ]; then
              echo "âŒ $service is not running"
              all_healthy=false
            else
              echo "âœ… $service is running ($running_count tasks)"
            fi
          done
          
          if $all_healthy; then
            echo "should_rollback=true" >> $GITHUB_OUTPUT
            echo "âœ… Rollback is feasible"
          else
            echo "should_rollback=false" >> $GITHUB_OUTPUT
            echo "âŒ Some services are not healthy. Manual intervention required."
            exit 1
          fi

  # Job 2: Pre-rollback backup
  pre-rollback-backup:
    name: Pre-rollback Backup
    runs-on: ubuntu-latest
    needs: [validate-rollback]
    if: needs.validate-rollback.outputs.should_rollback == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Create pre-rollback database backup
        run: |
          echo "Creating pre-rollback database backup..."
          
          # Get database endpoint
          cd terraform
          terraform init -backend=false
          DB_ENDPOINT=$(terraform output -raw database_endpoint || echo "")
          cd ..
          
          if [ -n "$DB_ENDPOINT" ]; then
            # Create backup
            BACKUP_FILE="pre-rollback-backup-$(date +%Y%m%d-%H%M%S).sql"
            
            PGPASSWORD="${{ secrets.DB_PASSWORD }}" pg_dump \
              -h $DB_ENDPOINT \
              -U ${{ secrets.DB_USERNAME }} \
              -d ${{ secrets.DB_NAME }} \
              -f $BACKUP_FILE
            
            # Store backup in S3
            aws s3 cp $BACKUP_FILE s3://${{ secrets.BACKUP_S3_BUCKET }}/rollback-backups/
            
            echo "âœ… Pre-rollback backup created: $BACKUP_FILE"
          else
            echo "âŒ Database endpoint not found"
            exit 1
          fi
          
      - name: Save current service states
        run: |
          echo "Saving current service states..."
          
          services=("api-gateway" "user-service" "product-service" "order-service" "notification-service")
          
          # Create service state backup
          cat > current-service-state.json << EOF
          {
            "rollback_id": "${{ github.run_id }}",
            "rollback_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "reason": "${{ github.event.inputs.reason }}",
            "triggered_by": "${{ github.actor }}",
            "services": {}
          }
          EOF
          
          for service in "${services[@]}"; do
            # Get current task definition ARN
            TASK_DEF_ARN=$(aws ecs describe-services \
              --cluster ${{ env.PROJECT_NAME }}-cluster \
              --services ${{ env.PROJECT_NAME }}-$service \
              --query 'services[0].taskDefinition' \
              --output text)
            
            # Add to state file
            jq --arg service "$service" --arg task_def "$TASK_DEF_ARN" \
              '.services[$service] = {"taskDefinition": $task_def}' \
              current-service-state.json > temp.json && mv temp.json current-service-state.json
          done
          
          # Upload to S3
          aws s3 cp current-service-state.json s3://${{ secrets.BACKUP_S3_BUCKET }}/rollback-backups/current-state-${{ github.run_id }}.json
          
          echo "âœ… Current service states saved"

  # Job 3: Execute rollback
  execute-rollback:
    name: Execute Rollback
    runs-on: ubuntu-latest
    needs: [validate-rollback, pre-rollback-backup]
    if: needs.validate-rollback.outputs.should_rollback == 'true'
    strategy:
      matrix:
        service: [api-gateway, user-service, product-service, order-service, notification-service]
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Rollback ${{ matrix.service }}
        run: |
          echo "Rolling back ${{ matrix.service }}..."
          
          # Parse rollback info
          ROLLBACK_INFO='${{ needs.validate-rollback.outputs.rollback_info }}'
          PREVIOUS_VERSION=$(echo "$ROLLBACK_INFO" | jq -r '.previous_version')
          
          if [ "$PREVIOUS_VERSION" = "null" ] || [ -z "$PREVIOUS_VERSION" ]; then
            echo "âŒ Previous version not found for ${{ matrix.service }}"
            exit 1
          fi
          
          echo "Rolling back to version: $PREVIOUS_VERSION"
          
          # Get the previous task definition
          PREVIOUS_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "${{ env.PROJECT_NAME }}-${{ matrix.service }}:$PREVIOUS_VERSION" \
            --query 'taskDefinition' \
            --output json)
          
          if [ "$?" -ne 0 ]; then
            echo "âŒ Previous task definition not found"
            exit 1
          fi
          
          # Clean up the task definition for registration
          CLEAN_TASK_DEF=$(echo "$PREVIOUS_TASK_DEF" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresCompatibilities, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register the rollback task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --family ${{ env.PROJECT_NAME }}-${{ matrix.service }} \
            --cli-input-json "$CLEAN_TASK_DEF")
          
          if [ "$?" -ne 0 ]; then
            echo "âŒ Failed to register rollback task definition"
            exit 1
          fi
          
          # Update service to use rollback task definition
          aws ecs update-service \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --service ${{ env.PROJECT_NAME }}-${{ matrix.service }} \
            --task-definition ${{ env.PROJECT_NAME }}-${{ matrix.service }} \
            --force-new-deployment
          
          if [ "$?" -eq 0 ]; then
            echo "âœ… ${{ matrix.service }} rollback initiated"
          else
            echo "âŒ Failed to rollback ${{ matrix.service }}"
            exit 1
          fi

  # Job 4: Wait for rollback completion
  wait-for-rollback:
    name: Wait for Rollback Completion
    runs-on: ubuntu-latest
    needs: [validate-rollback, execute-rollback]
    if: needs.validate-rollback.outputs.should_rollback == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Wait for rollback to complete
        run: |
          services=("api-gateway" "user-service" "product-service" "order-service" "notification-service")
          
          echo "Waiting for rollback to complete..."
          
          for service in "${services[@]}"; do
            echo "Waiting for $service rollback to stabilize..."
            
            aws ecs wait services-stable \
              --cluster ${{ env.PROJECT_NAME }}-cluster \
              --services ${{ env.PROJECT_NAME }}-$service \
              --region ${{ env.AWS_REGION }} \
              --cli-read-timeout 0 \
              --cli-connect-timeout 120
              
            if [ $? -eq 0 ]; then
              echo "âœ… $service rollback completed successfully"
            else
              echo "âŒ $service rollback failed to stabilize"
              exit 1
            fi
          done
          
          echo "ðŸŽ‰ All services rolled back successfully!"

  # Job 5: Post-rollback verification
  post-rollback-verification:
    name: Post-rollback Verification
    runs-on: ubuntu-latest
    needs: [validate-rollback, wait-for-rollback]
    if: needs.validate-rollback.outputs.should_rollback == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Verify rollback health
        run: |
          # Get production ALB DNS
          cd terraform
          terraform init -backend=false
          ALB_DNS=$(terraform output -raw load_balancer_dns || echo "")
          cd ..
          
          if [ -n "$ALB_DNS" ]; then
            echo "Verifying rollback health..."
            
            # Wait for ALB to register rolled back targets
            sleep 90
            
            # Test each service endpoint
            services=("" "users" "products" "orders" "notifications")
            
            for service in "${services[@]}"; do
              if [ -z "$service" ]; then
                endpoint="http://$ALB_DNS/health/"
                name="API Gateway"
              else
                endpoint="http://$ALB_DNS/$service/health/"
                name="$service Service"
              fi
              
              echo "Testing $name: $endpoint"
              
              # Retry health check multiple times
              for i in {1..5}; do
                response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint" || echo "000")
                
                if [ "$response" = "200" ]; then
                  echo "âœ… $name is healthy after rollback (attempt $i)"
                  break
                elif [ $i -eq 5 ]; then
                  echo "âŒ $name failed health check after rollback (last response: $response)"
                  exit 1
                else
                  echo "â³ $name health check failed (attempt $i), retrying..."
                  sleep 30
                fi
              done
            done
            
            echo "ðŸŽ‰ All services are healthy after rollback!"
          else
            echo "âŒ Production ALB DNS not found"
            exit 1
          fi
          
      - name: Run critical smoke tests
        run: |
          echo "Running critical smoke tests after rollback..."
          
          # Get production ALB DNS
          cd terraform
          terraform init -backend=false
          ALB_DNS=$(terraform output -raw load_balancer_dns || echo "")
          cd ..
          
          if [ -n "$ALB_DNS" ]; then
            # Basic API connectivity tests
            echo "Testing API connectivity..."
            
            # Test API Gateway
            if curl -f "http://$ALB_DNS/health/" > /dev/null 2>&1; then
              echo "âœ… API Gateway is responding"
            else
              echo "âŒ API Gateway is not responding"
              exit 1
            fi
            
            echo "ðŸŽ‰ Critical smoke tests passed!"
          else
            echo "âŒ Unable to run smoke tests - ALB DNS not found"
            exit 1
          fi

  # Job 6: Rollback notification
  rollback-notification:
    name: Rollback Notification
    runs-on: ubuntu-latest
    needs: [validate-rollback, wait-for-rollback, post-rollback-verification]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Generate rollback report
        run: |
          echo "## ðŸ”„ Production Rollback Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Rollback Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Rollback Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Original Deployment ID**: ${{ github.event.inputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Rollback ID**: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason**: ${{ github.event.inputs.reason }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Rollback time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Job Results:" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: ${{ needs.validate-rollback.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Pre-rollback Backup**: ${{ needs.pre-rollback-backup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Rollback Execution**: ${{ needs.execute-rollback.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Rollback Completion**: ${{ needs.wait-for-rollback.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Post-rollback Verification**: ${{ needs.post-rollback-verification.result }}" >> $GITHUB_STEP_SUMMARY
          
      - name: Post to Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#production-deployments'
          title: 'ðŸ”„ Production Rollback'
          message: |
            *Production Rollback ${{ job.status }}*
            Original Deployment: ${{ github.event.inputs.deployment_id }}
            Rollback ID: ${{ github.run_id }}
            Reason: ${{ github.event.inputs.reason }}
            Triggered by: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }} 